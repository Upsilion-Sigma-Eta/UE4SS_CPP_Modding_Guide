<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">
<h1 style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">Struct (구조체)</h1>
<h2 style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">1. 구조체란 무엇이며, 왜 필요한가?</h2>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"></div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">
<blockquote style="font-family: Helvetica, Arial, sans-serif; line-height: 1.0; margin: 0; padding: 0; border-left: 5px solid #ccc; background-color: #f8f8f8; position: relative; z-index: 1; min-height: 1em;">
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"><em style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">"복잡성을 통제하는 것이 컴퓨터 프로그래밍의 기초다." - 브라이언 커니건(Brian Kernigan, 컴퓨터 과학자, 최초로 C언어 프로그래밍이란 책을 저술)</em><br style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"><em style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">"좋은 소프트웨어의 기능이란 복잡한 것을 간단하게 보이도록 만드는 것이다." - 그래디 부치(Grady Booch, UML 개발자)</em></div>
</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0; text-align: right;"><em style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">개발자의 삶 - [번역글] 컴퓨터 프로그래밍에 대한 명언 101가지</em></div>
</blockquote>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"></div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">한 권의 책이 있다고 해 봅시다. 이 책에 적힌 모든 글자를 장, 절, 문단등의 구분이 없이 길게 죽 내려 썼다고 생각해보세요. 똑같은 내용이지만 원하는 내용을 찾기가 어려워질거고, 수정이라도 하려고 하면 엄청난 시간과 노력이 필요할 겁니다. 하지만 이 모든 것을 체계적으로 정리 해 놓는다면 어떨까요? 책의 내용을 장과 절로 만들고, 연관성 있는 항목들끼리 묶어놓았다면, 우리가 책의 내용을 수정하기는 훨씬 편하지 않을까요? 우리가 프로그래밍에서 여러가지 변수들과 필요하다면 함수를 묶어 놓아야 하는 상황이 있습니다. 만약 체계적으로 정리해놓지 않는다면, 나중에 SW를 수정해야 할 떄 어느 부분을 수정해야 할 지 알 수 없을 것입니다. 그렇게 된다면 잘 정리되었다면 몇 분 만에 끝날 일을 몇십 분, 몇백 분 동안 해야 할 수도 있고, 최악의 경우에는 완전히 다시 코드를 짜야 할 수도 있습니다. 지금부터 소개할 구조체와 클래스(Class)가 없었다면 수많은 변수들을 묶어놓지 못하고 풀어 헤쳐놓은 채로 작업을 해야 했을 것입니다. 함수나 변수가 수백개에서 수천개에 달한다면, 코드를 수정하기가 더욱 괴로웠을 것입니다. 그렇다면 이 구조체라는 것이 UE4SS Modding과 무슨 상관이 있을까요? 구조체를 사용하고와 사용하지 않고는 함수의 가독성에 큰 영향을 미칩니다. 아래 예시를 잠깐 보실까요?</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"></div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">
<pre class="language-cpp" style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;"><code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">SomeNamespace::Function(int a, int b, int c, ...)
SomeNamespace::Function(struct BunchOfParameters)</code></pre>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"></div>
</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">SomeNamespace::Function(int a, int b, int c, int d ...)와 SomeNamespace::Function(struct BunchOfParameter) 중 간결한 쪽은 후자이며, 파라미터로 넘기는 것들의 의미가 더 명확한 것도 후자입니다. 전자보다는 후자가 더 복잡하지 않고 간단하며, 더 깔끔해 보입니다. 구조체의 대표적인 역할은 바로 이런 식으로 변수들을 묶어주는 것에 있다고 볼 수 있습니다. C++의 struct는 함수 또한 묶을 수 있는 기능을 제공하며, class와 사실상 동일한 기능을 수행할 수 있지만, 그 부분에 대해서는 일단 넘어가도록 합시다.</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"></div>
<h2 style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">2. UE4SS로 C++ 모드를 만들 때 구조체의 역할</h2>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">그렇다면 이런 구조체는 어떻게 사용될까요? UE4SS에서 구조체의 사용법 중 중요한 것은 함수를 Hooking 했을 때입니다. 이 떄 함수의 파라미터는 void* 형태로 나타나게 됩니다. 함수의 파라미터가 여러개이든, 하나 뿐이든, 전부 void* 하나로만 나타납니다. 어떻게 함수에서 받은 파라미터 값들을 가져올 수 있을까요? Pointer 문서에서 설명하였듯이, 포인터들은 각 값의 주소를 가리키고, 포인터의 타입은 읽어올 연속된 메모리의 개수를 의미합니다. void는 어떤 값도 가지지 않으므로, void*는 얼마만큼의 값을 읽어올 지 명확하게 정해지지 않은 상태로&nbsp; 특정 메모리 공간의 시작 주소를 가리킬 뿐입니다. 따라서, 우리는 단순히 void*를 역참조 할 수 없습니다. 컴퓨터는 이 void*에서, 얼마만큼의 메모리를 읽어야 할 지 모르기 떄문입니다. 따라서, 우리는 void*를 적절한 형의 포인터로 변환해야 합니다.</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">void*는 어떤 데이터 타입의 시작 주소든 가리킬 수 있고, 이 데이터 타입들에는 사용자 정의 데이터 타입이라고 볼 수 있는 구조체와 클래스도 예외가 아닙니다. <strong style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">UE4SS에서 파라미터는 하나의 구조체로서 후킹된 함수에 전달됩니다.</strong> 포인터 편에서 말했듯이, 한 변수는 연속된 메모리 공간을 가집니다. 이 말은, <strong style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">우리가 전달받는 파라미터들의 타입(메모리 공간 크기)와 갯수를 알 수 있다면, 파라미터들의 주소를 받아오는 구조체를 만들 수 있다</strong>는 이야기입니다. 아래는 함수의 파라미터를 우리가 조작할 수 있도록 해주는 예제입니다.</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">
<pre class="language-cpp" style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;"><code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">    void PlayerNoTakeDamagePreProcessing(RC::Unreal::UnrealScriptFunctionCallableContext&amp; Context, void* customData)
    {
        struct ContextParams {
            float Damage;
            uint8 DamageEvent[0x10];
            UObject* EventInstigator;
            UObject* DamageCauser;
        };
        ContextParams* params = &amp;(Context.GetParams&lt;ContextParams&gt;());
       // 기타 코드들...
}</code></pre>

<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">위 예제 코드는 Void Interactive에서 개발한 Ready or Not 게임의 한 함수를 후킹한 것입니다. 주목할 부분은 함수를 후킹했을 때 넘어오는 Context입니다. Context는 참조 형식으로 전달되며(이는 컴파일 시점에서 내부적으로 포인터로 변환됨을 Pointer 문서에서 설명하였습니다.), <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">Context.GetParams&lt;Type&gt;()</code>형태의 함수는 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">Type</code>형태의 반환값을 반환합니다. 이 함수의 매개변수는 Dump 파일에서 확인했을 때, <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">float</code>, <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">uint8</code>, <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">UObject*</code>, <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">UObject*</code>를 전달받습니다. 구조체를 이용해서 파라미터를 받아오기 위해서는 메모리 레이아웃(Memory Layout)을 엄격하게 지켜서 가져와야 합니다. 그렇지 않으면 엉뚱한 데이터를 가져와 참조할 수 있고, 이는 Access Violation Error로 이어질 수 있습니다.</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">구조체를 좀 더 자세히 살펴보도록 합시다. <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">struct COntextParams</code>구조체는 매개변수의 타입을 앞에서부터 순서대로 배열합니다. 한 가지 특이한 점은 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">DamageEvent</code> 변수의 타입이 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">uint8</code>배열로 선언되어 있고, 배열의 크기가 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">0x10</code>이라는 것입니다. 이런 과정이 왜 필요할까요? 이 역시 메모리 레이아웃을 준수하기 위해서 입니다. <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">DamageEvent</code>는 구조체 변수이고, 해당 구조체가 메모리에서 차지하는 크기는 CXX Header나 UTH Header 또는 Dump 파일에서 확인할 수 있습니다. 10바이트의 크기를 가진 구조체(또는 클래스)이기 때문에, 우리는 해당 값만큼의 공간을 배정해 주어야 합니다. 따라서, <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">uint8 DamageEvent[0x10]</code>으로 float 변수 다음에 10바이트를 차지하도록 한 것입니다.</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;"><code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">ContextParams* params = &amp;(Context.GetParams&lt;ContextParams&gt;()</code> 문은 파라미터가 저장되어있는 포인터인 void*를 가져와서 자동으로 우리가 정의한 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">ContextParams</code>타입으로 변환 후, 해당 포인터가 가리키는 지점부터 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">ContextParams</code>타입 만큼의 메모리를 가지는 객체를 반환합니다.&nbsp; 즉, 우리는 "이 void*는 이 구조체와 똑같은 메모리 레이아웃을 가지고 있다."라고 알려주는 것입니다. <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">ContextParams</code> 타입의 구조체 포인터를 선언하고, 변환된 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">ContextParams</code>객체의 주소를 얻기 위해서 역참조 연산자(&amp;)를 사용합니다. 그리고 그 객체의 주소는 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">ContextParms*</code>포인터가 받아서 가지게 됩니다. 이제 우리는 <code style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; line-height: 1.0;">params-&gt;Damage</code>와 같은 표현을 통해서 파라미터에 접근하여 값을 변경하거나, 읽어올 수 있게 되었습니다!</div>
<div style="min-height: 1em; margin: 0; padding: 0; font-family: Helvetica, Arial, sans-serif; font-size: 16px; line-height: 1.0;">함수에 파라미터를 넘겨주는 방법에 대해서는 Function(함수) 파트에서 다루도록 하겠습니다.</div>

